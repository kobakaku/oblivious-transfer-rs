use anyhow::{anyhow, Result};
use rand::rngs::OsRng;
use rand::RngCore;
use rsa::{PaddingScheme, PublicKey, PublicKeyParts, RsaPrivateKey, RsaPublicKey};

mod xor;

/// Choice enum for 1-out-of-2 OT
#[derive(Clone, Debug, Copy, PartialEq)]
pub enum Choice {
    Zero,
    One,
}

impl Choice {
    pub fn from_bit(bit: u8) -> Result<Self> {
        match bit {
            0 => Ok(Choice::Zero),
            1 => Ok(Choice::One),
            _ => Err(anyhow!("Invalid choice bit: {}", bit)),
        }
    }

    pub fn to_bit(&self) -> u8 {
        match self {
            Choice::Zero => 0,
            Choice::One => 1,
        }
    }
}

/// Modified RSA-based OT implementation with XOR masking
/// Sender generates RSA keys and uses XOR masking for message transfer
#[derive(Clone, Debug)]
pub struct OTSender {
    messages: Vec<Vec<u8>>,
    private_key: Option<RsaPrivateKey>,
    public_key: Option<RsaPublicKey>,
}

pub struct OTReceiver {
    choice: Choice,
    x: Option<Vec<u8>>, // Random value x generated by receiver
}

/// Public key sent from sender to receiver
#[derive(Clone)]
pub struct SenderPublicKey {
    pub pk: RsaPublicKey,
}

/// Encrypted values sent from receiver to sender
#[derive(Clone)]
pub struct ReceiverEncryptedValues {
    pub c0: Vec<u8>, // Encrypted y0
    pub c1: Vec<u8>, // Encrypted y1
}

/// Sender's response with masked messages
#[derive(Clone)]
pub struct SenderMaskedMessages {
    pub k0: Vec<u8>, // Decrypted C0 XOR m0
    pub k1: Vec<u8>, // Decrypted C1 XOR m1
}

impl OTSender {
    /// Create a new RSA-based OT sender with two messages
    pub fn new(message0: Vec<u8>, message1: Vec<u8>) -> Result<Self> {
        Ok(OTSender {
            messages: vec![message0, message1],
            private_key: None,
            public_key: None,
        })
    }

    /// Phase 1: Generate RSA key pair and send public key to receiver
    pub fn generate_keys(&mut self) -> Result<SenderPublicKey> {
        let mut rng = OsRng;
        let bits = 2048; // Increased for better security

        self.private_key = Some(RsaPrivateKey::new(&mut rng, bits)?);
        self.public_key = Some(RsaPublicKey::from(self.private_key.as_ref().unwrap()));

        Ok(SenderPublicKey {
            pk: self.public_key.as_ref().unwrap().clone(),
        })
    }

    /// Phase 3: Decrypt received values and mask with messages
    pub fn create_masked_messages(
        &self,
        receiver_values: ReceiverEncryptedValues,
    ) -> Result<SenderMaskedMessages> {
        let private_key = self
            .private_key
            .as_ref()
            .ok_or_else(|| anyhow!("Private key not generated"))?;

        // Decrypt C0 and C1
        let decrypted_c0 =
            private_key.decrypt(PaddingScheme::new_pkcs1v15_encrypt(), &receiver_values.c0)?;
        let decrypted_c1 =
            private_key.decrypt(PaddingScheme::new_pkcs1v15_encrypt(), &receiver_values.c1)?;

        // XOR with messages: K0 = decrypted_C0 ⊕ m0, K1 = decrypted_C1 ⊕ m1
        let k0 = xor::xor(&decrypted_c0, &self.messages[0])?;
        let k1 = xor::xor(&decrypted_c1, &self.messages[1])?;

        Ok(SenderMaskedMessages { k0, k1 })
    }
}

impl OTReceiver {
    /// Create a new RSA-based OT receiver with a choice
    pub fn new(choice: Choice) -> Self {
        OTReceiver { choice, x: None }
    }

    /// Phase 2: Generate random value x and create encrypted values y0, y1
    /// If b=0: y0=x, y1=random
    /// If b=1: y0=random, y1=x
    pub fn generate_encrypted_values(
        &mut self,
        sender_pk: SenderPublicKey,
    ) -> Result<ReceiverEncryptedValues> {
        let mut rng = OsRng;

        // Generate random value x (must be smaller than RSA modulus for encryption)
        // For PKCS#1 v1.5, message must be at most k-11 bytes where k is the key size in bytes
        let key_size_bytes = sender_pk.pk.size();
        let max_message_size = key_size_bytes - 11; // PKCS#1 v1.5 padding overhead

        // Use a reasonable size for the random values (e.g., 32 bytes for 256-bit security)
        let random_size = std::cmp::min(32, max_message_size);

        let mut x = vec![0u8; random_size];
        rng.fill_bytes(&mut x);
        self.x = Some(x.clone());

        // Generate random value for the non-chosen position
        let mut random_value = vec![0u8; random_size];
        rng.fill_bytes(&mut random_value);

        // Set y0 and y1 based on choice
        let (y0, y1) = match self.choice {
            Choice::Zero => (x, random_value),
            Choice::One => (random_value, x),
        };

        // Encrypt y0 and y1 with sender's public key
        let c0 = sender_pk
            .pk
            .encrypt(&mut rng, PaddingScheme::new_pkcs1v15_encrypt(), &y0)?;
        let c1 = sender_pk
            .pk
            .encrypt(&mut rng, PaddingScheme::new_pkcs1v15_encrypt(), &y1)?;

        Ok(ReceiverEncryptedValues { c0, c1 })
    }

    /// Phase 4: Extract the chosen message using XOR
    /// If b=0: compute K0 ⊕ x to get m0
    /// If b=1: compute K1 ⊕ x to get m1
    pub fn extract_message(&self, masked_messages: SenderMaskedMessages) -> Result<Vec<u8>> {
        let x = self
            .x
            .as_ref()
            .ok_or_else(|| anyhow!("Invalid protocol state: x not generated"))?;

        // Select the appropriate masked message based on choice
        let masked_message = match self.choice {
            Choice::Zero => &masked_messages.k0,
            Choice::One => &masked_messages.k1,
        };

        // Extract message: mb = Kb ⊕ x
        let mut message = xor::xor(masked_message, x)?;

        // Remove trailing zeros that were added during padding
        while message.last() == Some(&0) {
            message.pop();
        }

        Ok(message)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rsa_ot_with_xor_choice_zero() -> Result<()> {
        let message0 = b"Hello Alice!".to_vec();
        let message1 = b"Hello Bob!!".to_vec();

        // Create sender and receiver
        let mut sender = OTSender::new(message0.clone(), message1.clone())?;
        let mut receiver = OTReceiver::new(Choice::Zero);

        // Phase 1: Sender generates RSA key pair and sends public key
        let sender_pk = sender.generate_keys()?;

        // Phase 2: Receiver generates encrypted values (C0, C1)
        let encrypted_values = receiver.generate_encrypted_values(sender_pk)?;

        // Phase 3: Sender decrypts and creates masked messages (K0, K1)
        let masked_messages = sender.create_masked_messages(encrypted_values)?;

        // Phase 4: Receiver extracts chosen message
        let decrypted = receiver.extract_message(masked_messages)?;

        // Verify we got the correct message
        assert_eq!(decrypted, message0);
        Ok(())
    }

    #[test]
    fn test_rsa_ot_with_xor_choice_one() -> Result<()> {
        let message0 = b"Secret Zero".to_vec();
        let message1 = b"Secret One!".to_vec();

        let mut sender = OTSender::new(message0.clone(), message1.clone())?;
        let mut receiver = OTReceiver::new(Choice::One);

        let sender_pk = sender.generate_keys()?;
        let encrypted_values = receiver.generate_encrypted_values(sender_pk)?;
        let masked_messages = sender.create_masked_messages(encrypted_values)?;
        let decrypted = receiver.extract_message(masked_messages)?;

        // Verify we got the correct message
        assert_eq!(decrypted, message1);
        Ok(())
    }
}
